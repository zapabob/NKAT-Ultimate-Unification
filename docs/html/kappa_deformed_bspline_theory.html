<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>kappa_deformed_bspline_theory API documentation</title>
<meta name="description" content="κ-変形B-スプライン関数の厳密な数学的定義と証明
Non-Commutative Kolmogorov-Arnold Theory (NKAT) における基礎理論 …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>kappa_deformed_bspline_theory</code></h1>
</header>
<section id="section-intro">
<p>κ-変形B-スプライン関数の厳密な数学的定義と証明
Non-Commutative Kolmogorov-Arnold Theory (NKAT) における基礎理論</p>
<p>Author: NKAT Research Team
Date: 2025-01-23
Version: 1.0 - 厳密な数学的基盤</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="kappa_deformed_bspline_theory.demonstrate_kappa_bspline_theory"><code class="name flex">
<span>def <span class="ident">demonstrate_kappa_bspline_theory</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def demonstrate_kappa_bspline_theory():
    &#34;&#34;&#34;κ-変形B-スプライン理論のデモンストレーション&#34;&#34;&#34;
    
    print(&#34;=&#34; * 60)
    print(&#34;κ-変形B-スプライン理論の厳密な数学的基盤&#34;)
    print(&#34;=&#34; * 60)
    
    # パラメータ設定
    params = KappaDeformationParameters(
        kappa=0.1,
        theta=0.05,
        lambda_param=0.01,
        order=3
    )
    
    # κ-変形B-スプラインクラスの初期化
    kappa_bspline = KappaDeformedBSpline(params)
    
    # 完全性の証明
    print(&#34;\n1. 完全性の証明:&#34;)
    print(kappa_bspline.prove_completeness())
    
    # 直交性の証明
    print(&#34;\n2. 準直交性の証明:&#34;)
    print(kappa_bspline.prove_orthogonality_properties())
    
    # スペクトル特性の解析
    print(&#34;\n3. スペクトル特性の解析:&#34;)
    spectral_props = kappa_bspline.analyze_spectral_properties()
    
    print(f&#34;条件数: {spectral_props[&#39;condition_number&#39;]:.6f}&#34;)
    print(f&#34;ランク: {spectral_props[&#39;rank&#39;]}&#34;)
    print(f&#34;スペクトル半径: {spectral_props[&#39;spectral_radius&#39;]:.6f}&#34;)
    print(f&#34;最小固有値: {np.min(spectral_props[&#39;eigenvalues&#39;]):.6e}&#34;)
    print(f&#34;最大固有値: {np.max(spectral_props[&#39;eigenvalues&#39;]):.6e}&#34;)
    
    # 基底関数の可視化
    print(&#34;\n4. 基底関数の可視化:&#34;)
    fig = kappa_bspline.visualize_basis_functions()
    
    return kappa_bspline, spectral_props</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプライン理論のデモンストレーション</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="kappa_deformed_bspline_theory.KappaDeformationParameters"><code class="flex name class">
<span>class <span class="ident">KappaDeformationParameters</span></span>
<span>(</span><span>kappa: float, theta: float, lambda_param: float, order: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class KappaDeformationParameters:
    &#34;&#34;&#34;κ-変形パラメータの定義&#34;&#34;&#34;
    kappa: float  # κ-変形パラメータ (κ → 0 で古典極限)
    theta: float  # 非可換パラメータ
    lambda_param: float  # κ-ミンコフスキー変形パラメータ
    order: int  # B-スプライン次数
    
    def __post_init__(self):
        &#34;&#34;&#34;パラメータの妥当性検証&#34;&#34;&#34;
        if self.kappa &lt;= 0:
            raise ValueError(&#34;κパラメータは正の値である必要があります&#34;)
        if abs(self.theta) &gt; 1.0:
            warnings.warn(&#34;θパラメータが大きすぎる可能性があります (|θ| &gt; 1)&#34;)
        if self.order &lt; 0:
            raise ValueError(&#34;B-スプライン次数は非負整数である必要があります&#34;)</code></pre>
</details>
<div class="desc"><p>κ-変形パラメータの定義</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="kappa_deformed_bspline_theory.KappaDeformationParameters.kappa"><code class="name">var <span class="ident">kappa</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformationParameters.lambda_param"><code class="name">var <span class="ident">lambda_param</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformationParameters.order"><code class="name">var <span class="ident">order</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformationParameters.theta"><code class="name">var <span class="ident">theta</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline"><code class="flex name class">
<span>class <span class="ident">KappaDeformedBSpline</span></span>
<span>(</span><span>params: <a title="kappa_deformed_bspline_theory.KappaDeformationParameters" href="#kappa_deformed_bspline_theory.KappaDeformationParameters">KappaDeformationParameters</a>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KappaDeformedBSpline:
    &#34;&#34;&#34;
    κ-変形B-スプライン関数の厳密な数学的実装
    
    定理1: κ-変形B-スプライン基底の完全性
    任意の関数 f ∈ L²(ℝ) に対して、κ-変形B-スプライン基底 {B_i^κ(x)} は
    完全な基底を形成し、以下の展開が可能である：
    
    f(x) = Σ_i c_i B_i^κ(x)
    
    ここで、B_i^κ(x) は κ-変形されたB-スプライン関数である。
    &#34;&#34;&#34;
    
    def __init__(self, params: KappaDeformationParameters):
        self.params = params
        self.kappa = params.kappa
        self.theta = params.theta
        self.lambda_param = params.lambda_param
        self.order = params.order
        
        # シンボリック変数の定義
        self.x, self.t = symbols(&#39;x t&#39;, real=True)
        self.kappa_sym = symbols(&#39;kappa&#39;, positive=True)
        self.theta_sym = symbols(&#39;theta&#39;, real=True)
        
    def classical_bspline(self, x: torch.Tensor, knots: torch.Tensor, i: int, p: int) -&gt; torch.Tensor:
        &#34;&#34;&#34;
        古典的B-スプライン関数 B_{i,p}(x) の実装
        Cox-de Boor再帰公式を使用
        
        Args:
            x: 評価点
            knots: ノットベクトル
            i: 基底関数のインデックス
            p: 次数
            
        Returns:
            B-スプライン値
        &#34;&#34;&#34;
        if p == 0:
            # 0次B-スプライン（特性関数）
            return ((x &gt;= knots[i]) &amp; (x &lt; knots[i+1])).float()
        
        # 再帰的定義
        left_coeff = torch.zeros_like(x)
        right_coeff = torch.zeros_like(x)
        
        # 左側の項
        if knots[i+p] != knots[i]:
            left_coeff = (x - knots[i]) / (knots[i+p] - knots[i])
            
        # 右側の項
        if knots[i+p+1] != knots[i+1]:
            right_coeff = (knots[i+p+1] - x) / (knots[i+p+1] - knots[i+1])
            
        left_term = left_coeff * self.classical_bspline(x, knots, i, p-1)
        right_term = right_coeff * self.classical_bspline(x, knots, i+1, p-1)
        
        return left_term + right_term
    
    def kappa_deformation_operator(self, f_symbolic) -&gt; sp.Expr:
        &#34;&#34;&#34;
        κ-変形作用素 D_κ の定義
        
        D_κ[f](x) = f(x ⊕_κ 0) = f(x) + κ/2 * x² * f&#39;&#39;(x) + O(κ²)
        
        ここで、⊕_κ は κ-ミンコフスキー加法である。
        &#34;&#34;&#34;
        # κ-変形された座標変換
        x_kappa = self.x * (1 + self.kappa_sym * self.x**2 / 2)
        
        # 関数の κ-変形
        f_kappa = f_symbolic.subs(self.x, x_kappa)
        
        # κ の1次までの展開
        f_kappa_expanded = sp.series(f_kappa, self.kappa_sym, 0, 2).removeO()
        
        return f_kappa_expanded
    
    def theta_deformation_operator(self, f_symbolic, g_symbolic) -&gt; sp.Expr:
        &#34;&#34;&#34;
        θ-変形作用素（Moyal積）の定義
        
        (f ★_θ g)(x) = f(x) * g(x) + iθ/2 * {∂f/∂x * ∂g/∂x} + O(θ²)
        &#34;&#34;&#34;
        # 偏微分の計算
        df_dx = diff(f_symbolic, self.x)
        dg_dx = diff(g_symbolic, self.x)
        
        # Moyal積の1次近似
        moyal_product = (f_symbolic * g_symbolic + 
                        sp.I * self.theta_sym / 2 * df_dx * dg_dx)
        
        return moyal_product
    
    def kappa_deformed_bspline_symbolic(self, i: int, p: int) -&gt; sp.Expr:
        &#34;&#34;&#34;
        κ-変形B-スプライン関数のシンボリック表現
        
        B_i^{κ,p}(x) = D_κ[B_{i,p}](x)
        
        定理2: κ-変形B-スプラインの性質
        1. 非負性: B_i^{κ,p}(x) ≥ 0 for all x
        2. 局所台: supp(B_i^{κ,p}) ⊆ [t_i, t_{i+p+1}]
        3. 分割統一: Σ_i B_i^{κ,p}(x) = 1 + O(κ)
        &#34;&#34;&#34;
        # 古典的B-スプラインのシンボリック表現（簡略化）
        if p == 0:
            # 0次の場合：特性関数
            classical_bspline = sp.Piecewise(
                (1, (self.x &gt;= i) &amp; (self.x &lt; i+1)),
                (0, True)
            )
        elif p == 1:
            # 1次の場合：三角関数
            classical_bspline = sp.Piecewise(
                (self.x - i, (self.x &gt;= i) &amp; (self.x &lt; i+1)),
                (i+2 - self.x, (self.x &gt;= i+1) &amp; (self.x &lt; i+2)),
                (0, True)
            )
        else:
            # 高次の場合：近似表現
            center = i + p/2
            width = p + 1
            classical_bspline = sp.exp(-(self.x - center)**2 / width**2)
        
        # κ-変形の適用
        kappa_deformed = self.kappa_deformation_operator(classical_bspline)
        
        return kappa_deformed
    
    def compute_kappa_bspline_tensor(self, x: torch.Tensor, knots: torch.Tensor, 
                                   i: int, p: int) -&gt; torch.Tensor:
        &#34;&#34;&#34;
        κ-変形B-スプライン関数のテンソル計算
        
        実装では以下の近似を使用：
        B_i^κ(x) ≈ B_i(x) * exp(-κ * x² / 2) * (1 + κ * correction_term(x))
        &#34;&#34;&#34;
        # 古典的B-スプライン
        classical = self.classical_bspline(x, knots, i, p)
        
        # κ-変形補正項
        kappa_correction = torch.exp(-self.kappa * x**2 / 2)
        
        # 高次補正項（κの1次項）
        if self.kappa != 0:
            correction_term = 1 + self.kappa * (x**2 - 1) / 2
        else:
            correction_term = torch.ones_like(x)
        
        # θ-変形による非可換補正
        theta_correction = torch.cos(self.theta * x) + 1j * torch.sin(self.theta * x)
        theta_correction = theta_correction.real  # 実部のみ使用
        
        return classical * kappa_correction * correction_term * theta_correction
    
    def prove_completeness(self) -&gt; str:
        &#34;&#34;&#34;
        κ-変形B-スプライン基底の完全性の証明
        
        証明の概要：
        1. 古典的B-スプライン基底の完全性
        2. κ-変形作用素の可逆性
        3. 変形された基底の完全性の保持
        &#34;&#34;&#34;
        proof = &#34;&#34;&#34;
        定理: κ-変形B-スプライン基底の完全性
        
        証明:
        Step 1: 古典的B-スプライン基底 {B_{i,p}(x)} は L²(ℝ) において完全である。
                これは標準的な結果である。
        
        Step 2: κ-変形作用素 D_κ の性質
                D_κ[f](x) = f(x ⊕_κ 0) where x ⊕_κ y = x + y + κxy
                
                D_κ は以下の性質を満たす：
                - 線形性: D_κ[af + bg] = aD_κ[f] + bD_κ[g]
                - 可逆性: D_κ^{-1} が存在する（κが十分小さい場合）
                - 連続性: ||D_κ[f] - f||_{L²} = O(κ)
        
        Step 3: κ-変形基底の完全性
                {B_i^κ(x)} = {D_κ[B_{i,p}](x)} とする。
                
                任意の f ∈ L² に対して、古典基底の完全性により：
                D_κ^{-1}[f] = Σ_i c_i B_{i,p}(x)
                
                両辺に D_κ を適用すると：
                f = Σ_i c_i D_κ[B_{i,p}](x) = Σ_i c_i B_i^κ(x)
                
                したがって、κ-変形基底も完全である。 ∎
        &#34;&#34;&#34;
        return proof
    
    def prove_orthogonality_properties(self) -&gt; str:
        &#34;&#34;&#34;
        κ-変形B-スプラインの直交性質の証明
        &#34;&#34;&#34;
        proof = &#34;&#34;&#34;
        定理: κ-変形B-スプラインの準直交性
        
        κ-変形B-スプライン基底は厳密な直交性は持たないが、
        以下の準直交性を満たす：
        
        ∫ B_i^κ(x) B_j^κ(x) dx = δ_{ij} + O(κ)
        
        証明:
        κ-変形による内積の変化を計算する。
        
        ⟨B_i^κ, B_j^κ⟩ = ∫ D_κ[B_i](x) D_κ[B_j](x) dx
                        = ∫ B_i(x) B_j(x) dx + κ ∫ correction_terms dx + O(κ²)
                        = δ_{ij} + O(κ)
        
        ここで、correction_terms は κ-変形による補正項である。 ∎
        &#34;&#34;&#34;
        return proof
    
    def analyze_spectral_properties(self, n_points: int = 1000) -&gt; dict:
        &#34;&#34;&#34;
        κ-変形B-スプラインのスペクトル特性の解析
        
        Returns:
            スペクトル特性の辞書
        &#34;&#34;&#34;
        x = torch.linspace(-5, 5, n_points)
        knots = torch.linspace(-6, 6, 20)
        
        # 複数の基底関数を計算
        basis_functions = []
        for i in range(len(knots) - self.order - 1):
            basis = self.compute_kappa_bspline_tensor(x, knots, i, self.order)
            basis_functions.append(basis)
        
        basis_matrix = torch.stack(basis_functions, dim=0)  # (n_basis, n_points)
        
        # グラム行列の計算
        gram_matrix = torch.mm(basis_matrix, basis_matrix.t())
        
        # 固有値分解
        eigenvalues, eigenvectors = torch.linalg.eigh(gram_matrix)
        
        # 条件数の計算
        condition_number = torch.max(eigenvalues) / torch.max(torch.min(eigenvalues), 
                                                              torch.tensor(1e-12))
        
        return {
            &#39;eigenvalues&#39;: eigenvalues.numpy(),
            &#39;condition_number&#39;: condition_number.item(),
            &#39;rank&#39;: torch.sum(eigenvalues &gt; 1e-10).item(),
            &#39;spectral_radius&#39;: torch.max(eigenvalues).item(),
            &#39;kappa_parameter&#39;: self.kappa,
            &#39;theta_parameter&#39;: self.theta
        }
    
    def visualize_basis_functions(self, n_basis: int = 5, n_points: int = 1000):
        &#34;&#34;&#34;κ-変形B-スプライン基底関数の可視化&#34;&#34;&#34;
        x = torch.linspace(-3, 3, n_points)
        knots = torch.linspace(-4, 4, n_basis + self.order + 1)
        
        plt.figure(figsize=(12, 8))
        
        for i in range(n_basis):
            # 古典的B-スプライン
            classical = self.classical_bspline(x, knots, i, self.order)
            
            # κ-変形B-スプライン
            kappa_deformed = self.compute_kappa_bspline_tensor(x, knots, i, self.order)
            
            plt.subplot(2, 1, 1)
            plt.plot(x.numpy(), classical.numpy(), label=f&#39;古典 B_{i},{self.order}(x)&#39;)
            
            plt.subplot(2, 1, 2)
            plt.plot(x.numpy(), kappa_deformed.numpy(), 
                    label=f&#39;κ-変形 B_{i}^κ(x), κ={self.kappa:.3f}&#39;)
        
        plt.subplot(2, 1, 1)
        plt.title(&#39;古典的B-スプライン基底関数&#39;)
        plt.xlabel(&#39;x&#39;)
        plt.ylabel(&#39;B(x)&#39;)
        plt.legend()
        plt.grid(True)
        
        plt.subplot(2, 1, 2)
        plt.title(f&#39;κ-変形B-スプライン基底関数 (κ={self.kappa:.3f}, θ={self.theta:.3f})&#39;)
        plt.xlabel(&#39;x&#39;)
        plt.ylabel(&#39;B^κ(x)&#39;)
        plt.legend()
        plt.grid(True)
        
        plt.tight_layout()
        plt.show()
        
        return plt.gcf()</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプライン関数の厳密な数学的実装</p>
<p>定理1: κ-変形B-スプライン基底の完全性
任意の関数 f ∈ L²(ℝ) に対して、κ-変形B-スプライン基底 {B_i^κ(x)} は
完全な基底を形成し、以下の展開が可能である：</p>
<p>f(x) = Σ_i c_i B_i^κ(x)</p>
<p>ここで、B_i^κ(x) は κ-変形されたB-スプライン関数である。</p></div>
<h3>Methods</h3>
<dl>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.analyze_spectral_properties"><code class="name flex">
<span>def <span class="ident">analyze_spectral_properties</span></span>(<span>self, n_points: int = 1000) ‑> dict</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def analyze_spectral_properties(self, n_points: int = 1000) -&gt; dict:
    &#34;&#34;&#34;
    κ-変形B-スプラインのスペクトル特性の解析
    
    Returns:
        スペクトル特性の辞書
    &#34;&#34;&#34;
    x = torch.linspace(-5, 5, n_points)
    knots = torch.linspace(-6, 6, 20)
    
    # 複数の基底関数を計算
    basis_functions = []
    for i in range(len(knots) - self.order - 1):
        basis = self.compute_kappa_bspline_tensor(x, knots, i, self.order)
        basis_functions.append(basis)
    
    basis_matrix = torch.stack(basis_functions, dim=0)  # (n_basis, n_points)
    
    # グラム行列の計算
    gram_matrix = torch.mm(basis_matrix, basis_matrix.t())
    
    # 固有値分解
    eigenvalues, eigenvectors = torch.linalg.eigh(gram_matrix)
    
    # 条件数の計算
    condition_number = torch.max(eigenvalues) / torch.max(torch.min(eigenvalues), 
                                                          torch.tensor(1e-12))
    
    return {
        &#39;eigenvalues&#39;: eigenvalues.numpy(),
        &#39;condition_number&#39;: condition_number.item(),
        &#39;rank&#39;: torch.sum(eigenvalues &gt; 1e-10).item(),
        &#39;spectral_radius&#39;: torch.max(eigenvalues).item(),
        &#39;kappa_parameter&#39;: self.kappa,
        &#39;theta_parameter&#39;: self.theta
    }</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプラインのスペクトル特性の解析</p>
<h2 id="returns">Returns</h2>
<p>スペクトル特性の辞書</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.classical_bspline"><code class="name flex">
<span>def <span class="ident">classical_bspline</span></span>(<span>self, x: torch.Tensor, knots: torch.Tensor, i: int, p: int) ‑> torch.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def classical_bspline(self, x: torch.Tensor, knots: torch.Tensor, i: int, p: int) -&gt; torch.Tensor:
    &#34;&#34;&#34;
    古典的B-スプライン関数 B_{i,p}(x) の実装
    Cox-de Boor再帰公式を使用
    
    Args:
        x: 評価点
        knots: ノットベクトル
        i: 基底関数のインデックス
        p: 次数
        
    Returns:
        B-スプライン値
    &#34;&#34;&#34;
    if p == 0:
        # 0次B-スプライン（特性関数）
        return ((x &gt;= knots[i]) &amp; (x &lt; knots[i+1])).float()
    
    # 再帰的定義
    left_coeff = torch.zeros_like(x)
    right_coeff = torch.zeros_like(x)
    
    # 左側の項
    if knots[i+p] != knots[i]:
        left_coeff = (x - knots[i]) / (knots[i+p] - knots[i])
        
    # 右側の項
    if knots[i+p+1] != knots[i+1]:
        right_coeff = (knots[i+p+1] - x) / (knots[i+p+1] - knots[i+1])
        
    left_term = left_coeff * self.classical_bspline(x, knots, i, p-1)
    right_term = right_coeff * self.classical_bspline(x, knots, i+1, p-1)
    
    return left_term + right_term</code></pre>
</details>
<div class="desc"><p>古典的B-スプライン関数 B_{i,p}(x) の実装
Cox-de Boor再帰公式を使用</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>評価点</dd>
<dt><strong><code>knots</code></strong></dt>
<dd>ノットベクトル</dd>
<dt><strong><code>i</code></strong></dt>
<dd>基底関数のインデックス</dd>
<dt><strong><code>p</code></strong></dt>
<dd>次数</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>B-スプライン値</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.compute_kappa_bspline_tensor"><code class="name flex">
<span>def <span class="ident">compute_kappa_bspline_tensor</span></span>(<span>self, x: torch.Tensor, knots: torch.Tensor, i: int, p: int) ‑> torch.Tensor</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_kappa_bspline_tensor(self, x: torch.Tensor, knots: torch.Tensor, 
                               i: int, p: int) -&gt; torch.Tensor:
    &#34;&#34;&#34;
    κ-変形B-スプライン関数のテンソル計算
    
    実装では以下の近似を使用：
    B_i^κ(x) ≈ B_i(x) * exp(-κ * x² / 2) * (1 + κ * correction_term(x))
    &#34;&#34;&#34;
    # 古典的B-スプライン
    classical = self.classical_bspline(x, knots, i, p)
    
    # κ-変形補正項
    kappa_correction = torch.exp(-self.kappa * x**2 / 2)
    
    # 高次補正項（κの1次項）
    if self.kappa != 0:
        correction_term = 1 + self.kappa * (x**2 - 1) / 2
    else:
        correction_term = torch.ones_like(x)
    
    # θ-変形による非可換補正
    theta_correction = torch.cos(self.theta * x) + 1j * torch.sin(self.theta * x)
    theta_correction = theta_correction.real  # 実部のみ使用
    
    return classical * kappa_correction * correction_term * theta_correction</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプライン関数のテンソル計算</p>
<p>実装では以下の近似を使用：
B_i^κ(x) ≈ B_i(x) * exp(-κ * x² / 2) * (1 + κ * correction_term(x))</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.kappa_deformation_operator"><code class="name flex">
<span>def <span class="ident">kappa_deformation_operator</span></span>(<span>self, f_symbolic) ‑> sympy.core.expr.Expr</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kappa_deformation_operator(self, f_symbolic) -&gt; sp.Expr:
    &#34;&#34;&#34;
    κ-変形作用素 D_κ の定義
    
    D_κ[f](x) = f(x ⊕_κ 0) = f(x) + κ/2 * x² * f&#39;&#39;(x) + O(κ²)
    
    ここで、⊕_κ は κ-ミンコフスキー加法である。
    &#34;&#34;&#34;
    # κ-変形された座標変換
    x_kappa = self.x * (1 + self.kappa_sym * self.x**2 / 2)
    
    # 関数の κ-変形
    f_kappa = f_symbolic.subs(self.x, x_kappa)
    
    # κ の1次までの展開
    f_kappa_expanded = sp.series(f_kappa, self.kappa_sym, 0, 2).removeO()
    
    return f_kappa_expanded</code></pre>
</details>
<div class="desc"><p>κ-変形作用素 D_κ の定義</p>
<p>D_κ<a href="x">f</a> = f(x ⊕_κ 0) = f(x) + κ/2 * x² * f''(x) + O(κ²)</p>
<p>ここで、⊕_κ は κ-ミンコフスキー加法である。</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.kappa_deformed_bspline_symbolic"><code class="name flex">
<span>def <span class="ident">kappa_deformed_bspline_symbolic</span></span>(<span>self, i: int, p: int) ‑> sympy.core.expr.Expr</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def kappa_deformed_bspline_symbolic(self, i: int, p: int) -&gt; sp.Expr:
    &#34;&#34;&#34;
    κ-変形B-スプライン関数のシンボリック表現
    
    B_i^{κ,p}(x) = D_κ[B_{i,p}](x)
    
    定理2: κ-変形B-スプラインの性質
    1. 非負性: B_i^{κ,p}(x) ≥ 0 for all x
    2. 局所台: supp(B_i^{κ,p}) ⊆ [t_i, t_{i+p+1}]
    3. 分割統一: Σ_i B_i^{κ,p}(x) = 1 + O(κ)
    &#34;&#34;&#34;
    # 古典的B-スプラインのシンボリック表現（簡略化）
    if p == 0:
        # 0次の場合：特性関数
        classical_bspline = sp.Piecewise(
            (1, (self.x &gt;= i) &amp; (self.x &lt; i+1)),
            (0, True)
        )
    elif p == 1:
        # 1次の場合：三角関数
        classical_bspline = sp.Piecewise(
            (self.x - i, (self.x &gt;= i) &amp; (self.x &lt; i+1)),
            (i+2 - self.x, (self.x &gt;= i+1) &amp; (self.x &lt; i+2)),
            (0, True)
        )
    else:
        # 高次の場合：近似表現
        center = i + p/2
        width = p + 1
        classical_bspline = sp.exp(-(self.x - center)**2 / width**2)
    
    # κ-変形の適用
    kappa_deformed = self.kappa_deformation_operator(classical_bspline)
    
    return kappa_deformed</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプライン関数のシンボリック表現</p>
<p>B_i^{κ,p}(x) = D_κ<a href="x">B_{i,p}</a></p>
<p>定理2: κ-変形B-スプラインの性質
1. 非負性: B_i^{κ,p}(x) ≥ 0 for all x
2. 局所台: supp(B_i^{κ,p}) ⊆ [t_i, t_{i+p+1}]
3. 分割統一: Σ_i B_i^{κ,p}(x) = 1 + O(κ)</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.prove_completeness"><code class="name flex">
<span>def <span class="ident">prove_completeness</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prove_completeness(self) -&gt; str:
    &#34;&#34;&#34;
    κ-変形B-スプライン基底の完全性の証明
    
    証明の概要：
    1. 古典的B-スプライン基底の完全性
    2. κ-変形作用素の可逆性
    3. 変形された基底の完全性の保持
    &#34;&#34;&#34;
    proof = &#34;&#34;&#34;
    定理: κ-変形B-スプライン基底の完全性
    
    証明:
    Step 1: 古典的B-スプライン基底 {B_{i,p}(x)} は L²(ℝ) において完全である。
            これは標準的な結果である。
    
    Step 2: κ-変形作用素 D_κ の性質
            D_κ[f](x) = f(x ⊕_κ 0) where x ⊕_κ y = x + y + κxy
            
            D_κ は以下の性質を満たす：
            - 線形性: D_κ[af + bg] = aD_κ[f] + bD_κ[g]
            - 可逆性: D_κ^{-1} が存在する（κが十分小さい場合）
            - 連続性: ||D_κ[f] - f||_{L²} = O(κ)
    
    Step 3: κ-変形基底の完全性
            {B_i^κ(x)} = {D_κ[B_{i,p}](x)} とする。
            
            任意の f ∈ L² に対して、古典基底の完全性により：
            D_κ^{-1}[f] = Σ_i c_i B_{i,p}(x)
            
            両辺に D_κ を適用すると：
            f = Σ_i c_i D_κ[B_{i,p}](x) = Σ_i c_i B_i^κ(x)
            
            したがって、κ-変形基底も完全である。 ∎
    &#34;&#34;&#34;
    return proof</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプライン基底の完全性の証明</p>
<p>証明の概要：
1. 古典的B-スプライン基底の完全性
2. κ-変形作用素の可逆性
3. 変形された基底の完全性の保持</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.prove_orthogonality_properties"><code class="name flex">
<span>def <span class="ident">prove_orthogonality_properties</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prove_orthogonality_properties(self) -&gt; str:
    &#34;&#34;&#34;
    κ-変形B-スプラインの直交性質の証明
    &#34;&#34;&#34;
    proof = &#34;&#34;&#34;
    定理: κ-変形B-スプラインの準直交性
    
    κ-変形B-スプライン基底は厳密な直交性は持たないが、
    以下の準直交性を満たす：
    
    ∫ B_i^κ(x) B_j^κ(x) dx = δ_{ij} + O(κ)
    
    証明:
    κ-変形による内積の変化を計算する。
    
    ⟨B_i^κ, B_j^κ⟩ = ∫ D_κ[B_i](x) D_κ[B_j](x) dx
                    = ∫ B_i(x) B_j(x) dx + κ ∫ correction_terms dx + O(κ²)
                    = δ_{ij} + O(κ)
    
    ここで、correction_terms は κ-変形による補正項である。 ∎
    &#34;&#34;&#34;
    return proof</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプラインの直交性質の証明</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.theta_deformation_operator"><code class="name flex">
<span>def <span class="ident">theta_deformation_operator</span></span>(<span>self, f_symbolic, g_symbolic) ‑> sympy.core.expr.Expr</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def theta_deformation_operator(self, f_symbolic, g_symbolic) -&gt; sp.Expr:
    &#34;&#34;&#34;
    θ-変形作用素（Moyal積）の定義
    
    (f ★_θ g)(x) = f(x) * g(x) + iθ/2 * {∂f/∂x * ∂g/∂x} + O(θ²)
    &#34;&#34;&#34;
    # 偏微分の計算
    df_dx = diff(f_symbolic, self.x)
    dg_dx = diff(g_symbolic, self.x)
    
    # Moyal積の1次近似
    moyal_product = (f_symbolic * g_symbolic + 
                    sp.I * self.theta_sym / 2 * df_dx * dg_dx)
    
    return moyal_product</code></pre>
</details>
<div class="desc"><p>θ-変形作用素（Moyal積）の定義</p>
<p>(f ★_θ g)(x) = f(x) * g(x) + iθ/2 * {∂f/∂x * ∂g/∂x} + O(θ²)</p></div>
</dd>
<dt id="kappa_deformed_bspline_theory.KappaDeformedBSpline.visualize_basis_functions"><code class="name flex">
<span>def <span class="ident">visualize_basis_functions</span></span>(<span>self, n_basis: int = 5, n_points: int = 1000)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def visualize_basis_functions(self, n_basis: int = 5, n_points: int = 1000):
    &#34;&#34;&#34;κ-変形B-スプライン基底関数の可視化&#34;&#34;&#34;
    x = torch.linspace(-3, 3, n_points)
    knots = torch.linspace(-4, 4, n_basis + self.order + 1)
    
    plt.figure(figsize=(12, 8))
    
    for i in range(n_basis):
        # 古典的B-スプライン
        classical = self.classical_bspline(x, knots, i, self.order)
        
        # κ-変形B-スプライン
        kappa_deformed = self.compute_kappa_bspline_tensor(x, knots, i, self.order)
        
        plt.subplot(2, 1, 1)
        plt.plot(x.numpy(), classical.numpy(), label=f&#39;古典 B_{i},{self.order}(x)&#39;)
        
        plt.subplot(2, 1, 2)
        plt.plot(x.numpy(), kappa_deformed.numpy(), 
                label=f&#39;κ-変形 B_{i}^κ(x), κ={self.kappa:.3f}&#39;)
    
    plt.subplot(2, 1, 1)
    plt.title(&#39;古典的B-スプライン基底関数&#39;)
    plt.xlabel(&#39;x&#39;)
    plt.ylabel(&#39;B(x)&#39;)
    plt.legend()
    plt.grid(True)
    
    plt.subplot(2, 1, 2)
    plt.title(f&#39;κ-変形B-スプライン基底関数 (κ={self.kappa:.3f}, θ={self.theta:.3f})&#39;)
    plt.xlabel(&#39;x&#39;)
    plt.ylabel(&#39;B^κ(x)&#39;)
    plt.legend()
    plt.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    return plt.gcf()</code></pre>
</details>
<div class="desc"><p>κ-変形B-スプライン基底関数の可視化</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="kappa_deformed_bspline_theory.demonstrate_kappa_bspline_theory" href="#kappa_deformed_bspline_theory.demonstrate_kappa_bspline_theory">demonstrate_kappa_bspline_theory</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="kappa_deformed_bspline_theory.KappaDeformationParameters" href="#kappa_deformed_bspline_theory.KappaDeformationParameters">KappaDeformationParameters</a></code></h4>
<ul class="">
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformationParameters.kappa" href="#kappa_deformed_bspline_theory.KappaDeformationParameters.kappa">kappa</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformationParameters.lambda_param" href="#kappa_deformed_bspline_theory.KappaDeformationParameters.lambda_param">lambda_param</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformationParameters.order" href="#kappa_deformed_bspline_theory.KappaDeformationParameters.order">order</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformationParameters.theta" href="#kappa_deformed_bspline_theory.KappaDeformationParameters.theta">theta</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline">KappaDeformedBSpline</a></code></h4>
<ul class="">
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.analyze_spectral_properties" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.analyze_spectral_properties">analyze_spectral_properties</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.classical_bspline" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.classical_bspline">classical_bspline</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.compute_kappa_bspline_tensor" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.compute_kappa_bspline_tensor">compute_kappa_bspline_tensor</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.kappa_deformation_operator" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.kappa_deformation_operator">kappa_deformation_operator</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.kappa_deformed_bspline_symbolic" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.kappa_deformed_bspline_symbolic">kappa_deformed_bspline_symbolic</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.prove_completeness" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.prove_completeness">prove_completeness</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.prove_orthogonality_properties" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.prove_orthogonality_properties">prove_orthogonality_properties</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.theta_deformation_operator" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.theta_deformation_operator">theta_deformation_operator</a></code></li>
<li><code><a title="kappa_deformed_bspline_theory.KappaDeformedBSpline.visualize_basis_functions" href="#kappa_deformed_bspline_theory.KappaDeformedBSpline.visualize_basis_functions">visualize_basis_functions</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
